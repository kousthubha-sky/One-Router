"""
OneRouter Python SDK
===================
Unified API client for payments, subscriptions, SMS, and more.

Installation:
    pip install onerouter

Usage:
    from onerouter import OneRouter
    
    client = OneRouter(api_key="unf_live_xxx")
    order = client.payments.create(amount=500.00, currency="INR")
"""

import httpx
import time
import hashlib
import secrets
from typing import Optional, Dict, Any, List
from enum import Enum


# ============================================
# EXCEPTIONS
# ============================================

class OneRouterError(Exception):
    """Base exception for all OneRouter errors"""
    pass


class AuthenticationError(OneRouterError):
    """API key is invalid or missing"""
    pass


class RateLimitError(OneRouterError):
    """Rate limit exceeded"""
    def __init__(self, message: str, retry_after: Optional[int] = None):
        super().__init__(message)
        self.retry_after = retry_after


class ValidationError(OneRouterError):
    """Request validation failed"""
    pass


class APIError(OneRouterError):
    """Generic API error"""
    def __init__(self, message: str, status_code: int, response: Optional[Dict] = None):
        super().__init__(message)
        self.status_code = status_code
        self.response = response


# ============================================
# HTTP CLIENT
# ============================================

class HTTPClient:
    """HTTP client with automatic retries and error handling"""
    
    def __init__(
        self,
        api_key: str,
        base_url: str = "https://api.onerouter.com",
        timeout: int = 30,
        max_retries: int = 3
    ):
        self.api_key = api_key
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout
        self.max_retries = max_retries
        
        self.client = httpx.AsyncClient(
            timeout=httpx.Timeout(timeout),
            headers={
                "X-Platform-Key": api_key,
                "Content-Type": "application/json",
                "User-Agent": "onerouter-python/1.0.0"
            }
        )
    
    async def request(
        self,
        method: str,
        endpoint: str,
        data: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
        idempotency_key: Optional[str] = None
    ) -> Dict[str, Any]:
        """Make HTTP request with retries"""
        url = f"{self.base_url}{endpoint}"
        headers = {}
        
        if idempotency_key:
            headers["Idempotency-Key"] = idempotency_key
        
        for attempt in range(self.max_retries):
            try:
                response = await self.client.request(
                    method=method,
                    url=url,
                    json=data,
                    params=params,
                    headers=headers
                )
                
                # Handle success
                if 200 <= response.status_code < 300:
                    return response.json()
                
                # Handle errors
                self._handle_error(response)
                
            except httpx.TimeoutException:
                if attempt == self.max_retries - 1:
                    raise APIError("Request timed out", status_code=504)
                await self._backoff(attempt)
            
            except httpx.NetworkError:
                if attempt == self.max_retries - 1:
                    raise APIError("Network error", status_code=503)
                await self._backoff(attempt)
        
        raise APIError("Max retries exceeded", status_code=503)
    
    def _handle_error(self, response: httpx.Response):
        """Parse error response and raise appropriate exception"""
        try:
            error_data = response.json()
            message = error_data.get("detail", "Unknown error")
        except:
            message = response.text or "Unknown error"
        
        if response.status_code == 401:
            raise AuthenticationError(f"Authentication failed: {message}")
        elif response.status_code == 429:
            retry_after = int(response.headers.get("Retry-After", "60"))
            raise RateLimitError(f"Rate limit exceeded: {message}", retry_after=retry_after)
        elif response.status_code == 422:
            raise ValidationError(f"Validation error: {message}")
        else:
            raise APIError(message, status_code=response.status_code, response=error_data)
    
    async def _backoff(self, attempt: int):
        """Exponential backoff between retries"""
        delay = min(2 ** attempt, 10)  # Max 10 seconds
        await asyncio.sleep(delay)
    
    async def close(self):
        """Close HTTP client"""
        await self.client.aclose()


# ============================================
# RESOURCE CLASSES
# ============================================

class PaymentsResource:
    """Payment operations"""
    
    def __init__(self, client: HTTPClient):
        self.client = client
    
    async def create(
        self,
        amount: float,
        currency: str = "INR",
        receipt: Optional[str] = None,
        notes: Optional[Dict[str, str]] = None,
        idempotency_key: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create a payment order
        
        Args:
            amount: Amount in currency units (e.g., 500.00 for â‚¹500)
            currency: Currency code (INR, USD, etc.)
            receipt: Optional receipt ID
            notes: Optional metadata
            idempotency_key: Optional idempotency key
        
        Returns:
            {
                "transaction_id": "txn_xxx",
                "provider": "razorpay",
                "provider_order_id": "order_xxx",
                "amount": 500.00,
                "currency": "INR",
                "status": "created",
                "checkout_url": "https://..."
            }
        """
        if not idempotency_key:
            idempotency_key = self._generate_idempotency_key()
        
        data = {
            "amount": amount,
            "currency": currency
        }
        
        if receipt:
            data["receipt"] = receipt
        if notes:
            data["notes"] = notes
        
        return await self.client.request(
            method="POST",
            endpoint="/v1/payments/orders",
            data=data,
            idempotency_key=idempotency_key
        )
    
    async def get(self, transaction_id: str) -> Dict[str, Any]:
        """Get payment order details"""
        return await self.client.request(
            method="GET",
            endpoint=f"/v1/payments/orders/{transaction_id}"
        )
    
    async def refund(
        self,
        payment_id: str,
        amount: Optional[float] = None,
        idempotency_key: Optional[str] = None
    ) -> Dict[str, Any]:
        """Create a refund (full or partial)"""
        if not idempotency_key:
            idempotency_key = self._generate_idempotency_key()
        
        data = {"payment_id": payment_id}
        if amount:
            data["amount"] = amount
        
        return await self.client.request(
            method="POST",
            endpoint="/v1/payments/refund",
            data=data,
            idempotency_key=idempotency_key
        )
    
    def _generate_idempotency_key(self) -> str:
        """Generate unique idempotency key"""
        return f"idem_{int(time.time())}_{secrets.token_hex(8)}"


class SubscriptionsResource:
    """Subscription operations"""
    
    def __init__(self, client: HTTPClient):
        self.client = client
    
    async def create(
        self,
        plan_id: str,
        customer_notify: bool = True,
        total_count: int = 12,
        quantity: int = 1
    ) -> Dict[str, Any]:
        """Create a subscription"""
        data = {
            "plan_id": plan_id,
            "customer_notify": customer_notify,
            "total_count": total_count,
            "quantity": quantity
        }
        
        return await self.client.request(
            method="POST",
            endpoint="/v1/subscriptions",
            data=data
        )
    
    async def get(self, subscription_id: str) -> Dict[str, Any]:
        """Get subscription details"""
        return await self.client.request(
            method="GET",
            endpoint=f"/v1/subscriptions/{subscription_id}"
        )
    
    async def cancel(
        self,
        subscription_id: str,
        cancel_at_cycle_end: bool = False
    ) -> Dict[str, Any]:
        """Cancel subscription"""
        data = {"cancel_at_cycle_end": cancel_at_cycle_end}
        
        return await self.client.request(
            method="POST",
            endpoint=f"/v1/subscriptions/{subscription_id}/cancel",
            data=data
        )


class PaymentLinksResource:
    """Payment link operations"""
    
    def __init__(self, client: HTTPClient):
        self.client = client
    
    async def create(
        self,
        amount: float,
        description: str,
        customer_email: Optional[str] = None
    ) -> Dict[str, Any]:
        """Create a payment link"""
        data = {
            "amount": amount,
            "description": description
        }
        
        if customer_email:
            data["customer_email"] = customer_email
        
        return await self.client.request(
            method="POST",
            endpoint="/v1/payment-links",
            data=data
        )


# ============================================
# MAIN CLIENT
# ============================================

class OneRouter:
    """
    OneRouter Unified API Client
    
    Usage:
        client = OneRouter(api_key="unf_live_xxx")
        
        # Create payment
        order = await client.payments.create(amount=500.00, currency="INR")
        
        # Create subscription
        sub = await client.subscriptions.create(plan_id="plan_123")
    """
    
    def __init__(
        self,
        api_key: str,
        base_url: str = "https://api.onerouter.com",
        timeout: int = 30,
        max_retries: int = 3
    ):
        """
        Initialize OneRouter client
        
        Args:
            api_key: Your OneRouter API key (unf_live_xxx or unf_test_xxx)
            base_url: API base URL (default: https://api.onerouter.com)
            timeout: Request timeout in seconds
            max_retries: Maximum retry attempts for failed requests
        """
        if not api_key:
            raise ValueError("API key is required")
        
        if not api_key.startswith(("unf_live_", "unf_test_")):
            raise ValueError("Invalid API key format. Must start with unf_live_ or unf_test_")
        
        self.http_client = HTTPClient(
            api_key=api_key,
            base_url=base_url,
            timeout=timeout,
            max_retries=max_retries
        )
        
        # Initialize resource classes
        self.payments = PaymentsResource(self.http_client)
        self.subscriptions = SubscriptionsResource(self.http_client)
        self.payment_links = PaymentLinksResource(self.http_client)
    
    async def close(self):
        """Close HTTP client (call this when done)"""
        await self.http_client.close()
    
    async def __aenter__(self):
        """Async context manager entry"""
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.close()


# ============================================
# USAGE EXAMPLES
# ============================================

async def example_usage():
    """Example: How to use the SDK"""
    
    # Initialize client
    async with OneRouter(api_key="unf_test_xxx") as client:
        
        # 1. Create payment
        order = await client.payments.create(
            amount=500.00,
            currency="INR",
            receipt="order_123",
            notes={"customer_id": "cust_456"}
        )
        print(f"Payment created: {order['transaction_id']}")
        print(f"Checkout URL: {order['checkout_url']}")
        
        # 2. Get payment status
        status = await client.payments.get(order['transaction_id'])
        print(f"Payment status: {status['status']}")
        
        # 3. Create subscription
        sub = await client.subscriptions.create(
            plan_id="plan_monthly_99",
            customer_notify=True
        )
        print(f"Subscription created: {sub['id']}")
        
        # 4. Create payment link
        link = await client.payment_links.create(
            amount=999.00,
            description="Premium subscription",
            customer_email="user@example.com"
        )
        print(f"Payment link: {link['short_url']}")


# ============================================
# SYNC WRAPPER (for non-async code)
# ============================================

import asyncio

class OneRouterSync:
    """Synchronous wrapper for OneRouter (for non-async code)"""
    
    def __init__(self, api_key: str, **kwargs):
        self.async_client = OneRouter(api_key=api_key, **kwargs)
        self._loop = asyncio.get_event_loop()
    
    def _run_async(self, coro):
        """Run async coroutine in sync context"""
        return self._loop.run_until_complete(coro)
    
    @property
    def payments(self):
        """Sync payments resource"""
        class SyncPayments:
            def __init__(self, async_payments, loop):
                self._async = async_payments
                self._loop = loop
            
            def create(self, **kwargs):
                return self._loop.run_until_complete(self._async.create(**kwargs))
            
            def get(self, transaction_id):
                return self._loop.run_until_complete(self._async.get(transaction_id))
            
            def refund(self, **kwargs):
                return self._loop.run_until_complete(self._async.refund(**kwargs))
        
        return SyncPayments(self.async_client.payments, self._loop)
    
    @property
    def subscriptions(self):
        """Sync subscriptions resource"""
        class SyncSubscriptions:
            def __init__(self, async_subs, loop):
                self._async = async_subs
                self._loop = loop
            
            def create(self, **kwargs):
                return self._loop.run_until_complete(self._async.create(**kwargs))
            
            def get(self, subscription_id):
                return self._loop.run_until_complete(self._async.get(subscription_id))
            
            def cancel(self, **kwargs):
                return self._loop.run_until_complete(self._async.cancel(**kwargs))
        
        return SyncSubscriptions(self.async_client.subscriptions, self._loop)
    
    def close(self):
        """Close client"""
        self._run_async(self.async_client.close())


def sync_example():
    """Example: Synchronous usage"""
    
    client = OneRouterSync(api_key="unf_test_xxx")
    
    try:
        # Create payment (no await needed)
        order = client.payments.create(
            amount=500.00,
            currency="INR"
        )
        print(f"Order: {order['transaction_id']}")
        
        # Get status
        status = client.payments.get(order['transaction_id'])
        print(f"Status: {status['status']}")
    
    finally:
        client.close()


if __name__ == "__main__":
    # Run async example
    asyncio.run(example_usage())
    
    # Or run sync example
    # sync_example()